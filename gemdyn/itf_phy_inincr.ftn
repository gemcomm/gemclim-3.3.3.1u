!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!**s/r itf_phy_inincr - define physics surface forcing increments
!
#include "model_macros_f.h"
!
      subroutine itf_phy_inincr
!
      implicit none
!
!author   
!     Bernard Dugas - july 97
!
!revision
! v2_21 - Bernard Dugas     - Adaption to GEM DM v2.2 and to physics v3.67:
!                             1) change all includes and variables to DM specs;
!                             2) each PE does the interpolations for its own area;
!                             3) INCRTS is only used for water points (TWATER);
!                             4) INCRTG is only used for glacier points (TGLACIER(2));
!                             5) INCRTP is only used for deep soil points when the
!                                force-restore surface scheme is selected (TSOIL(2));
!                             6) INCRICD is added for sea ice depht increments (ICEDP);
!                             7) INCRGL is now used with GLSEAS0, as GLSEA can be
!                                modified to account for lake ice evolution;
!                             8) INCRAL is no longer defined, since CALCALB
!                                is used instead (called by CLIMPHS2).
! v2_31 - Desgagne M.       - remove stkmemw
! v2_31 - Bernard Dugas     - adapt to new climatological file descriptors
! v2_32 - Bernard Dugas     - correct exit condition codes
! v3_00 - Desgagne & Lee    - Lam configuration
! v3_01 - Bernard Dugas     - add call to INTOZON
! v3_02 - Lubos Spacek      - remplacer l_ni et l_nj par p_ni et p_nj
! v3_02 - Bernard Dugas     - remettre le code de controle d'interpolation O3
!                           - toujours initialiser incrtp (independamment de soli_L)
! v3_10 - Lee V.            - RPN_bcastc for bcast on MPI_CHARACTER
! v3_11 - Bernard Dugas     - use glacier AND (maybe) sea ice SNODP to define INCRNE
!                           - Account for P_pbl_iceme_L = .true.
! v3_22 - Bernard Dugas     - add check for Done_inincr and correct xncibl(5) = 12
! v3_22 - Katja Winger      - make sure that BC are read twice in first month
!                             (at Lctl_step=2 and in the middle of the month)
! v3_30 - Dugas B.          - new itf_phy interface
! v3_32 - Winger K.         - allow minutely SST and sea ice BC's
!                             IP3:YYYY, IP2:MM, IP1:DDhhmm
!                           - assume monthly values at middle of month instead of 15th 12h
! v3_32 - Winger K.         - Change 'xnflds' -> 'Cfld_nbr' and 'clim_S' -> 'Cfld_list_S'.
!                             Put 'Cfld_nbr', 'Cfld_list_S', and 'Cfld_date' (coded 'Done_Inincr')
!                             in 'cfld.cdk' to write/read them in/from restart files.
! v3_33 - Dugas B.          - IP1 no longer used for DDhhmm info. DATEO used instead
!                           - support analysis data (deet > 0) in imanclima file
!                           
!                             
!
!object
!
!       Initialize the climatological increments field that
!       are in the permanent physics bus. Care has to be taken
!       with the active physics configuration, especially with
!       regards to the active surface parameterization.
!
!       The increments are those required by the routine CLIMPHS2
!       to simulate the evolution of some of the surface forcing
!       terms accounted for in the RPN/CMC physics package.
!
! ***   It is important to note that the physics package is
! ***   supposed to have been initialized by a previous call
! ***   to phy_init.
!
!       Climatology and analysed climatology file:
!       IP2 is always supposed to contain the month MM
!
!       Analysed climatology file:
!       IP3 is always supposed to contain the year YYYY
!       If there is more than 1 date per month day, hour and minute 
!       are to be found is the decoded DATEO descriptor
!       
!
!implicits
#include "dcst.cdk"
#include "lun.cdk"
#include "mem.cdk"
#include "path.cdk"
#include "itf_phy_buses.cdk"
#include "itf_phy_busind.cdk"
#include "ptopo.cdk"
#include "lctl.cdk"
#include "step.cdk"
#include "rstr.cdk"
#include "modconst.cdk"
#include "itf_phy_config.cdk"
#include "cstv.cdk"
#include "glb_ld.cdk"
#include "glb_pil.cdk"
#include "hgc.cdk"
#include "cfld.cdk"
!
!modules
      INTEGER,EXTERNAL :: newdate,fnom,fclos,wkoffit,fstopc,fstouv
      INTEGER,EXTERNAL :: fstinf,fstsui,fstlir,fstlirx,fstprm,fstfrm,fstnbr
      INTEGER,EXTERNAL :: ezgdef_fmem,ezsetopt,ezsint,ezdefset,ip1_all
!*
!
      REAL(8)      days_8,hour_8,rad_8
      character(16) xndate
!
      CHARACTER    gtyp_S(Cfld_nbr),gtypz_S(Cfld_nbr)
      INTEGER      xnzig1(Cfld_nbr),xnzig2(Cfld_nbr),xnzig3(Cfld_nbr)
      INTEGER      xnig1(Cfld_nbr), xnig2(Cfld_nbr), xnig3(Cfld_nbr)
      INTEGER      xnig4(Cfld_nbr), xnzig4(Cfld_nbr)
      INTEGER      xnilu(Cfld_nbr), xnjlu(Cfld_nbr)
!
      LOGICAL      IntSol_L,IntIce_L,NoLeapYears_L
      LOGICAL,     SAVE :: acli_L(Cfld_nbr)
      INTEGER      xniz,xnjz
      INTEGER      Lun_clim,Lun_acli,Lun_activ,ppjour,aujour
      INTEGER      xnerr,xncle,xnhold,xncoupe
      INTEGER      xni,xnj,xnk,xnim,xnjm, i,j,k,ik,n,x, lowb,upb
      INTEGER,     SAVE :: xnzm(Cfld_nbr),xnmxfld(Cfld_nbr)
      INTEGER      xnmxfld_max,xnzm_max
      CHARACTER(2) typvar_S,vide_S,hold_S*12
      CHARACTER(512) clima_S,anclima_S
      CHARACTER(8) soli_S
!
      REAL(8)      scal_8(Cfld_nbr)
      integer(8)   Done_Inincr(Cfld_nbr), Do_Inincr(Cfld_nbr)
!
      integer      offi,offj,indx,dgid,sgid
      real         neige, lxfi(l_ni),lyfi(l_nj), aucun(1)
      integer(8),  dimension (:,:)  , allocatable, save :: dates
      real,        dimension (:,:,:), allocatable :: xrwork
      real,        dimension (:,:)  , allocatable :: xrclim
      real,        dimension (:,:)  , allocatable :: xrtic,xrtac
      real,        dimension (:)    , pointer     :: busper
!
      LOGICAL,     save :: VRAI=.true.
!
!     Variables needed to read minutely SST & sea ice BC's
      INTEGER(8),  PARAMETER :: factor10=10000000000_8, &
     +                          factor8=100000000_8,
     +                          factor6=1000000_8,
     +                          factor4=10000_8
      INTEGER(8)   current_date
      INTEGER      curyy,curmo,curdd,curhh,curmm,curss,cursign
      INTEGER      handle, iip1,iip2,iip3, gii,gji,gif,gjf
      INTEGER      ip2(Cfld_nbr),ip3(Cfld_nbr),datev(Cfld_nbr)
      INTEGER      nrec_clim,nrec_acli,nrec_max
      INTEGER,     SAVE :: nrec(Cfld_nbr)
      INTEGER      year, month, day, hour, zulu
      INTEGER      dateo,deet,npas, datec, mo1
      INTEGER      date1,date2,time1,time2,stamp1,stamp2
      LOGICAL      open_acli_L, open_clim_L
      LOGICAL,     SAVE :: monthly_L(Cfld_nbr)
      CHARACTER(2),SAVE :: typv_S(Cfld_nbr)
      INTEGER      momid_day(12), momid_day_leap(12)
!
      DATA         momid_day      / 1612,1500,1612,1600,1612,1600,
     %                              1612,1612,1600,1612,1600,1612 /
      DATA         momid_day_leap / 1612,1512,1612,1600,1612,1600,
     %                              1612,1612,1600,1612,1600,1612 /

!
!*    Don't do anything at timestep 0
      if ( Lctl_step <= 0 ) return
!
      rad_8 = 45./atan( 1.0_8 )
!
!
!
!*       -------------------------------------------------
!*    1. Get the current date and time
!*       -------------------------------------------------
!
      days_8 = ( Lctl_step * (Cstv_dt_8 / 3600._8 ) ) / 24._8
      call incdatsd( xndate,Mod_runstrt_S,days_8 )
!
!*    internal dates are saved in a YYYY/MO/DD/HH/MM/SS format
      call prsdate( curyy,curmo,curdd,curhh,curmm,curss,cursign, xndate )
      Current_Date = curyy*factor10 + curmo*factor8 &
     +             + curdd*factor6  + curhh*factor4 &
     +             + curmm*100      + curss
!
!*    At very first time step initialize Done_Inincr to start of run
      if ( Lctl_step == 1 ) then
         call prsdate( curyy,curmo,curdd,curhh,curmm,curss,cursign, Mod_runstrt_S )
         Done_Inincr = curyy*factor10 + curmo*factor8
     +               + curdd*factor6  + curhh*factor4
     +               + curmm*100      + curss
!
!*    At all other time steps set Done_Inincr to Cfld_date (saved coded Done_Inincr)
      else
         do x=1,Cfld_nbr
!*          Decode date from 'Cfld_date' in 'Done_Inincr'
            if ( Cfld_date(x) > 0 ) then
               xnerr = newdate( Cfld_date(x), date1, time1, -3 )
               if ( xnerr > 0 ) call gem_stop( 'itf_phy_inincr',-8 )
               Done_Inincr(x) = date1*factor6 + time1/100
            else
               Done_Inincr(x) = -1
            end if
         end do
      end if
!
!
!*    Update the climatological ozone field every 24 hours
!*    (and note that it is first done at timestep 1)
!
      if (Cstv_dt_8 < 43200. ) then
!
         ppjour = nint( 86400. / Cstv_dt_8 )
         aujour = mod( Lctl_step, ppjour )
!
         if (Rstri_sdon > 0 .and.
     %       aujour    == 1 )
     %       call intozon( curdd,curmo, lun_out>0 )
!
      endif
!
      call Get_LeapYear_Status( NoLeapYears_L )
!
!
!*    Determine whether the surface land scheme is fully
!*    interactive or not. If it is, the TP increments will
!*    only be used for TGLACIER(2)
!
      call low2up( P_pbl_schsl_S,soli_S )

      if (soli_S  == 'CLASS' .or. soli_S == 'ISBA') then
         IntSol_L = .true.
      else
         IntSol_L = .false.
      endif
!
!*    Check for interactive snow (in glacier & sea ice
!*    modules) and ice thichness (in sea ice module)
!
      IntIce_L = P_pbl_iceme_L
!
!C    print *,'Dans itf_phy_inincr: soli_S ',soli_S
!C    call flush( Lun_out )
!
!
!
!*       -------------------------------------------------
!*    2. If 'Rstri_sdon=1' processor 0 reads all dates 
!*       in BC files imclima and imanclima
!*       -------------------------------------------------
!
      RSTRI_SDON_1 : if ( Rstri_sdon == 1 ) then
!
         PTOPO_MYPROC_0_1 : if ( Ptopo_myproc == 0 ) then
!
            if (Lun_out > 0) write( Lun_out,'(/A)')
     %      ' ITF_PHY_ININCR: checking content of forcing files'

            xnim    = 0
            xnjm    = 0
!
            Lun_clim = 0
            Lun_acli = 0
!
            nrec_clim = 0
            nrec_acli = 0
!
!*          Open file imanclima
            anclima_S =  trim(Path_input_S)//'/imanclima'
!
            xnerr = wkoffit( anclima_S )
!
            if ( xnerr == 1 .or. xnerr == 33 ) then
!
               xnerr = fnom( Lun_acli, anclima_S , 'STD+RND+OLD+R/O', 0 )
               xnerr = fstouv( Lun_acli, 'RND' )
!
               if ( xnerr >= 0 ) then
!
                  if (Lun_out > 0) write( Lun_out,* )
     %            'Opening file: ', trim( anclima_S )
!
!*                Get total number of records in file
                  nrec_acli = fstnbr (Lun_acli)
!
               end if
            end if
!
!
!*          Open file imclima
            clima_S = trim(Path_input_S)//'/imclima'
!
            xnerr = wkoffit( clima_S )
!
            if ( xnerr == 1 .or. xnerr == 33 ) then
!
               xnerr = fstopc( 'MSGLVL','INFORM', 0 )
               xnerr = fstopc( 'TOLRNC','INFORM', 0 )
               xnerr = fnom( Lun_clim, clima_S , 'STD+RND+OLD+R/O', 0 )
               xnerr = fstouv( Lun_clim, 'RND' )
!
               if ( xnerr >= 0 ) then
!
                  if (Lun_out > 0) write( Lun_out,* )
     %            'Opening file: ', trim( clima_S )
!
!*                Get total number of records in file
                  nrec_clim = fstnbr (Lun_clim)
!
               end if
            end if
!
!
!*          Get maximum number of records/date in files for allocation
            nrec_max = max( nrec_acli,nrec_clim )
!
         end if PTOPO_MYPROC_0_1
!
         call RPN_COMM_bcast( nrec_max,1      ,"MPI_INTEGER",0,"grid",xnerr )
         if ( nrec_max == 0 ) call gem_stop( 'itf_phy_inincr',-9 )
!
!*       All processors allocate 'dates'
         allocate ( dates(Cfld_nbr,nrec_max), stat=xnerr )
         If (xnerr > 0)  call gem_stop( 'itf_phy_inincr',-1 )
         dates = -1
!                
!*       Processor 0 reads all dates
         PTOPO_MYPROC_0_2 : if ( Ptopo_myproc == 0 ) then
!
!*          Read dates of records in file imanclimat
            if ( nrec_acli > 0 ) then
!
               do i=1,Cfld_nbr
!
                  if (    (Cfld_list_S(i) == 'SD' .and. IntIce_L .and. IntSol_L)
     %               .or. (Cfld_list_S(i) == 'I8' .and. IntIce_L)
     %               .or. (Cfld_list_S(i) == 'HS' .and. IntSol_L)) cycle

                  nrec(i) = 0
                  handle = fstinf( Lun_acli,xni,xnj,xnk,
     %                             -1,' ',-1,-1,-1,' ',Cfld_list_S(i) )
!
                  do while ( handle >= 0 )
!
                     xnim  = max( xnim,xni )
                     xnjm  = max( xnjm,xnj )
!
                     xnerr = fstprm( handle,dateo,deet,npas,
     %                               xnhold,xnhold,xnhold,
     %                               xnhold,xnhold,xnhold,iip2,iip3,
     %                               typv_S(i),hold_S,hold_S,hold_S,
     %                               xnhold,xnhold,xnhold,xnhold,
     %                               xnhold,xnhold,xnhold,xnhold,
     %                               xnhold,xnhold,xnhold )
!
                     nrec(i) = nrec(i) + 1
!
                     year = iip3 ; month = iip2 ; day = 0  ; zulu = 0 ; hour = 0

                     if ( deet > 0 .and. npas > 0 ) then ! maybe forecast data ?
                        hour_8 = ( deet * 1_8 * npas ) / 3600.0_8 ; hour  = nint( hour_8 )
                        call incdatr( datec,dateo, hour_8 )
                     else
                        datec = dateo
                     endif
!
                     xnerr = newdate( datec,date1,time1,-3 )
!
                     if (     date1/10000     == year  .and.
     +                   mod( date1/100,100 ) == month) then ! an extension to the default
                        day   = mod( date1,100 )
                        zulu  = time1/factor6
                     else if ( (hour == iip2 .and. deet > 0) .or.
     +                         month < 1 ) then ! use datec, probably forecast data
                        year  = date1/10000
                        month = mod( date1/100,100 )
                        day   = mod( date1,100 )
                        zulu  = time1/factor6
                     endif
!
!*                   Check if file contains monthly data (where
!*                   each monthly value is ordered consecutively)
                     if ( nrec(i) == 1 ) then
                        mo1 = month
                        monthly_L(i) = .true.
                     elseif ( monthly_L(i) ) then
                        if ( mod(mo1,12)+1 /= month ) monthly_L(i) = .false.
                        mo1 = month
                     end if
!
                     dates(i,nrec(i)) = year*factor10 + month*factor8
     +                                + day *factor6  + zulu *factor4
!
                     handle = fstsui( Lun_acli, xni,xnj,xnk )
!
                  enddo
!
                  if (nrec(i) > 0) acli_L(i) = .true.
!
                  xnmxfld(i) = xnim*xnjm
                  xnzm(i)    = max( xnim,xnjm )
!
!*                For monthly data set date to the middle of the month
                  if ( monthly_L(i) ) then
                     do n=1,nrec(i)
                        year  = int(  dates(i,n) / factor10 )
                        month = int( (dates(i,n) - year*factor10) / factor8 )
!
!*                      If leap year
                        if ( .not. NoLeapYears_L     .and.              &
     %                      ( mod( year,4 )   == 0   .and.
     %                        mod( year,100 ) /= 0 ) .or.
     %                        mod( year,400 ) == 0 ) then
                           dates(i,n) = year*factor10 + month*factor8
     %                                + momid_day_leap(month)*factor4
!*                      If non-leap year
                        else
                           dates(i,n) = year*factor10 + month*factor8
     %                                +      momid_day(month)*factor4
                        end if
!
                     end do
                  end if
!
               end do
!
               xnerr = fstfrm( Lun_acli )
               xnerr = fclos ( Lun_acli )
!
            end if
!
!*          Read dates of records in file imclimat
            if ( nrec_clim > 0 ) then
!
               do i=1,Cfld_nbr
!
                  if (    (Cfld_list_S(i) == 'SD' .and. IntIce_L .and. IntSol_L)
     %               .or. (Cfld_list_S(i) == 'I8' .and. IntIce_L)
     %               .or. (Cfld_list_S(i) == 'HS' .and. IntSol_L)) cycle

!*                Only try to read variable if not already found in imanclimat
!*                Don't need to read dates since it is a climatological file.
                  if ( .not. acli_L(i) ) then
!
                     handle = fstinf( Lun_clim,xni,xnj,xnk,
     %                                -1,' ',-1,-1,-1,' ',Cfld_list_S(i) )
!
                     do while ( handle >= 0 )
!
                        xnim  = max( xnim,xni )
                        xnjm  = max( xnjm,xnj )
!
                        handle = fstsui( Lun_clim, xni,xnj,xnk )
!
                     enddo
!
                     xnmxfld(i) = xnim*xnjm
                     xnzm(i)    = max( xnim,xnjm )
!
                     typv_S(i)  = 'C'
!
                  end if
               end do
!
               xnerr = fstfrm( Lun_clim )
               xnerr = fclos ( Lun_clim )
!
            end if   
!
         end if PTOPO_MYPROC_0_2
!
!
!        Broadcast a few variables
         call RPN_COMM_bcast ( nrec     ,Cfld_nbr           ,"MPI_INTEGER"  ,0,"grid",xnerr )
         call RPN_COMM_bcast ( xnmxfld  ,Cfld_nbr           ,"MPI_INTEGER"  ,0,"grid",xnerr )
         call RPN_COMM_bcast ( xnzm     ,Cfld_nbr           ,"MPI_INTEGER"  ,0,"grid",xnerr )
         call RPN_COMM_bcast ( dates    ,Cfld_nbr*nrec_max*2,"MPI_INTEGER"  ,0,"grid",xnerr )
         call RPN_COMM_bcast ( acli_L   ,Cfld_nbr           ,"MPI_LOGICAL"  ,0,"grid",xnerr )
         call RPN_COMM_bcast ( monthly_L,Cfld_nbr           ,"MPI_LOGICAL"  ,0,"grid",xnerr )
         call RPN_COMM_bcastc( typv_S   ,Cfld_nbr*2         ,"MPI_CHARACTER",0,"grid",xnerr )
!
      end if RSTRI_SDON_1
!
!
!*       -------------------------------------------------
!*    3. Check for each variable if a new date needs to be read
!*       -------------------------------------------------
!*
!*       Done_Inincr: Last date read
!*       Do_Inincr  : Next date to be read
!*       in a YYYY/MO/DD/HH/MM/SS format
!
      open_acli_L = .false.
      open_clim_L = .false.
      Do_Inincr   = Done_Inincr
!
!*    Loop over all variables
      LOOP_OVER_ALL_VARIABLES_1 : do i=1,Cfld_nbr
!
         if (    (Cfld_list_S(i) == 'SD' .and. IntIce_L .and. IntSol_L)
     %      .or. (Cfld_list_S(i) == 'I8' .and. IntIce_L)
     %      .or. (Cfld_list_S(i) == 'HS' .and. IntSol_L)) cycle
!
!*       If next date got already read, do nothing
         if ( Do_Inincr(i) >= current_date 
     %        .and. Lctl_step .ne. 1 ) cycle
!
!*       Find next date in analysed climatology imanclimat
         if ( acli_L(i) ) then
!
!*          Find the next date to read
            do n=1,nrec(i)
               if ( Do_Inincr(i) < dates(i,n) ) then
                  Do_Inincr(i) = dates(i,n)
                  exit
               end if
            end do
!
!*          Stop the run if new date was not found
            if ( Do_Inincr(i) < current_date ) then
               if (Lun_out > 0) write( Lun_out,1009 ) current_date
               call flush( Lun_out )
               call gem_stop('itf_phy_inincr',-2)
            end if
!
!*          Set DATEV,IP2-3 to date to be read
!
            If ( monthly_L(i) ) then
               ip3(i) =   Do_Inincr(i) /        factor10
               ip2(i) = ( Do_Inincr(i) - ip3(i)*factor10 ) / factor8
               datev(i) = -1
            Else
               date1 =      Do_Inincr(i)/factor6
               time1 = mod( Do_Inincr(i),factor6 )*100
               xnerr = newdate( datev(i),date1,time1,+3 )
               ip3(i) = -1 ; ip2(i) = -1
            End If
!
!*          Set flag that imanclimat needs to be opened
            open_acli_L = .true.
!
!        Set next date to be read in climatology imclimat
         else
!
            year  =   Do_Inincr(i) / factor10
            month = ( Do_Inincr(i) - year*factor10 ) / factor8
!
!*          Set day and time
!*          If leap year
 0050       if ( .not. NoLeapYears_L     .and.              &
     %          ( mod( year,4 )   == 0   .and.
     %            mod( year,100 ) /= 0 ) .or.
     %            mod( year,400 ) == 0 ) then
               Do_Inincr(i) = year*factor10 + month *factor8
     %                      +  momid_day_leap(month)*factor4
!*          If non-leap year
            else
               Do_Inincr(i) = year*factor10 + month *factor8
     %                      +       momid_day(month)*factor4
            end if
!             
!           Increment Do_Inincr if < current_date
            if ( Do_Inincr(i) < current_date ) then
               month = month + 1
               if ( month == 13 ) then
                  month = 01
                  year = year + 1
               end if
               goto 0050
            end if
! 
!*          Set DATEV,IP2-3 to date to be read
            datev(i) = -1
            ip3(i)   = -1
            ip2(i)   = month
!
!*          Set flag that imclimat needs to be opened
            open_clim_L = .true.
!
         end if
!
      end do LOOP_OVER_ALL_VARIABLES_1
!
!c    if ( Rstri_sdon == 15 ) then
!c    if ( Rstri_sdon == 408 ) then
!c    if ( Rstri_sdon == 408 ) then
!c       call gem_stop( 'itf_phy_inincr',-3 )
!c    end if

!
!
!     Return if no new fields need to be read
      if ( .not. open_acli_L .and. .not. open_clim_L ) return
!
!
!
!*       -------------------------------------------------
!*    4. Processor 0 opens imanclimat and/or imclimat
!*       -------------------------------------------------
!
      PTOPO_MYPROC_0_3 : if ( Ptopo_myproc == 0 ) then
!
         if (Lun_out > 0) write( Lun_out,'(/A)')
     %   ' ITF_PHY_ININCR: defining new physics forcing increments'

!*       Open analysied climatology imanclima if needed
         if ( open_acli_L ) then
!
            Lun_acli = 0
!
            anclima_S = trim(Path_input_S)//'/imanclima'
!
            xnerr = wkoffit( anclima_S )
!
            if ( xnerr == 1 .or. xnerr == 33 ) then
!
               xnerr = fnom( Lun_acli, anclima_S , 'STD+RND+OLD+R/O', 0 )
               xnerr = fstouv( Lun_acli, 'RND' )
!
               if ( xnerr >= 0 ) then
                  if (Lun_out > 0) write( Lun_out,* )
     %            'Opening file: ', trim( anclima_S )
               else
                  if (Lun_out > 0) write( Lun_out,1002 )
                  Lun_acli = 0
               end if
!
            else
               if (Lun_out > 0) write( Lun_out,1002 )
               Lun_acli = 0
            end if
! 
         end if
!
!
!*       Open climatology imclima if needed
         if ( open_clim_L ) then
!
            Lun_clim = 0
!
            clima_S = trim(Path_input_S)//'/imclima'
!
            xnerr = wkoffit( clima_S )
!
            if ( xnerr == 1 .or. xnerr == 33 ) then
!
               xnerr = fnom( Lun_clim, clima_S , 'STD+RND+OLD+R/O', 0 )
               xnerr = fstouv( Lun_clim, 'RND' )
!
               if ( xnerr >= 0 ) then
                  if (Lun_out > 0) write( Lun_out,* )
     %            'Opening file: ', trim( clima_S )
               else
                  if (Lun_out > 0) write( Lun_out,1001 ) trim( clima_S )
                  Lun_clim = 0
               end if
!
            else
               if (Lun_out > 0) write( Lun_out,1001 ) trim( clima_S )
               Lun_clim = 0
            end if
! 
         end if
!
      end if PTOPO_MYPROC_0_3
!
!     Broadcast a few variables
      call RPN_COMM_bcast( Lun_acli    ,1,"MPI_INTEGER",0,"grid",xnerr )
      call RPN_COMM_bcast( Lun_clim    ,1,"MPI_INTEGER",0,"grid",xnerr )
!
!*    Stop run if one of the files could not be opened
      if (( open_acli_L .and. Lun_acli == 0 ) .or.
     %    ( open_clim_L .and. Lun_clim == 0 ))
     %   call gem_stop( 'itf_phy_inincr',-4 )
!
!
!*       -------------------------------------------------
!*    5. Read fields for new dates
!*       -------------------------------------------------
!
!
!*    Every one allocates the Cfld_nbr 2D climatology fields
      xnzm_max    = maxval( xnzm(1:Cfld_nbr) )
      xnmxfld_max = maxval( xnmxfld(1:Cfld_nbr) )
!      
      allocate ( xrtic(xnzm_max,Cfld_nbr), xrtac(xnzm_max,Cfld_nbr), stat=xnerr )
      If (xnerr > 0)  call gem_stop( 'itf_phy_inincr',-5 )
      allocate ( xrclim(xnmxfld_max,Cfld_nbr),xrwork(l_ni,l_nj,Cfld_nbr), stat=xnerr )
      If (xnerr > 0) call gem_stop( 'itf_phy_inincr',-6 )
!
!
!*    Processor 0 reads fields for new date
      PTOPO_MYPROC_0_4 : if ( Ptopo_myproc == 0 ) then
!
         xnerr = fstopc( 'MSGLVL','INFORM', 0 )
         xnerr = fstopc( 'TOLRNC','INFORM', 0 )
!
!*       Loop over all variables
         LOOP_OVER_ALL_VARIABLES_2 : do i=1,Cfld_nbr
!
!*          Only read new date if needed
            if ( Done_Inincr(i) >= current_date 
     %           .and. Lctl_step /= 1 ) cycle
!
!*          Only read new date if needed
            if (    (Cfld_list_S(i) == 'SD' .and. IntIce_L .and. IntSol_L)
     %         .or. (Cfld_list_S(i) == 'I8' .and. IntIce_L)
     %         .or. (Cfld_list_S(i) == 'HS' .and. IntSol_L)) then
!
               if (Lun_out > 0) write( Lun_out,1004 ) Cfld_list_S(i)
!
            else
!
               xncle = -1
!
!              Read fields from analysed climatology imanclimat
               if ( acli_L(i) ) then
!
                  xncle = fstlir( xrclim(1,i), Lun_acli,
     %                            xni,xnj,xnk,  datev(i),' ',
     %                            -1,ip2(i),ip3(i),typv_S(i),
     %                            Cfld_list_S(i) )
!
                  if ( xncle < 0 ) then
                     if (Lun_out > 0) write( Lun_out,1005 ) Cfld_list_S(i)
                     goto 0040
                  endif
!
!              Read fields from climatology imclimat
               else
!
                  xncle = fstlir( xrclim(1,i), Lun_clim,
     %                            xni,xnj,xnk,  -1,' ',-1,ip2(i),
     %                            -1,typv_S(i),Cfld_list_S(i) )
!
                  if ( xncle < 0 ) then
                     if (Lun_out > 0) write( Lun_out,1005 ) Cfld_list_S(i)
                     goto 0040
                  endif
!
               end if
!
!
!*             Save the grid description parameters
               xnerr = fstprm( xncle, xnhold,xnhold,xnhold,
     %                         xnilu(i),xnjlu(i),xnk,
     %                         xnhold,xnhold,xnhold,xnhold,xnhold,
     %                         hold_S,hold_S,hold_S,
     %                         gtyp_S(i),xnig1(i),xnig2(i),
     %                                   xnig3(i),xnig4(i),
     %                         xnhold,xnhold,xnhold,xnhold,
     %                         xnhold,xnhold,xnhold )
!
!*             Retreive necessary Z-grid descriptors
               if (gtyp_S(i) == 'Z') then
!
                  if ( acli_L(i) ) then
                     Lun_activ = Lun_acli
                  else
                     Lun_activ = Lun_clim
                  endif
!
                  xncle = fstlir( xrtic(1,i), Lun_activ,
     %                            xniz,xnjz,xnhold, -1,' ',
     %                            xnig1(i),xnig2(i),xnig3(i),
     %                            ' ','>>')
!
                  if ( xncle < 0 .or.
     %                 xniz /= xnilu(i) ) then
                     write( Lun_out,1006 ) Lun_activ,xnig1(i),xnig2(i)
                     xncle = -1
                     goto 0040
                  endif
!                       
                  xncle = fstlir( xrtac(1,i), Lun_activ,
     %                            xniz,xnjz,xnhold, -1,' ',
     %                            xnig1(i),xnig2(i),xnig3(i),
     %                            ' ','^^')
!
                  if ( xncle < 0 .or.
     %                 xnjz /= xnjlu(i) ) then
                     write( Lun_out,1007 ) Lun_activ,xnig1(i),xnig2(i)
                     xncle = -1
                     goto 0040
                  endif
!
                  xnerr = fstprm( xncle, xnhold,xnhold,xnhold,
     %                            xnhold,xnhold,xnhold,
     %                            xnhold,xnhold,xnhold,xnhold,xnhold,
     %                            hold_S,hold_S,hold_S,
     %                            gtypz_S(i),xnzig1(i),xnzig2(i),
     %                                       xnzig3(i),xnzig4(i),
     %                            xnhold,xnhold,xnhold,xnhold,
     %                            xnhold,xnhold,xnhold )

!              end retreive necessary Z-grid descriptors
               endif
!
            end if
!
         End Do LOOP_OVER_ALL_VARIABLES_2
!
         xnerr = fstopc( 'MSGLVL','SYSTEM', 0 )
         xnerr = fstopc( 'TOLRNC','SYSTEM', 0 )
!
         if ( open_acli_L ) then
            xnerr = fstfrm( Lun_acli )
            xnerr = fclos ( Lun_acli )
         end if
         if ( open_clim_L ) then
            xnerr = fstfrm( Lun_clim )
            xnerr = fclos ( Lun_clim )
         end if
!
      end if PTOPO_MYPROC_0_4
!
!
!     Broadcast a few variables
 0040 call RPN_COMM_bcast( xncle  ,1               ,"MPI_INTEGER",0,"grid",xnerr)
      if (xncle < 0) call gem_stop( 'itf_phy_inincr',-7 )
!
      call RPN_COMM_bcast (xrtic  ,Cfld_nbr*xnzm_max   ,"MPI_REAL" ,0,"grid",xnerr)
      call RPN_COMM_bcast (xrtac  ,Cfld_nbr*xnzm_max   ,"MPI_REAL" ,0,"grid",xnerr)
      call RPN_COMM_bcast (xrclim ,Cfld_nbr*xnmxfld_max,"MPI_REAL" ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnilu  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnjlu  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnig1  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnig2  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnig3  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnig4  ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcastc(gtyp_S ,Cfld_nbr    ,"MPI_CHARACTER",0,"grid",xnerr)
      call RPN_COMM_bcast (xnzig1 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnzig2 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnzig3 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcast (xnzig4 ,Cfld_nbr    ,"MPI_INTEGER"  ,0,"grid",xnerr)
      call RPN_COMM_bcastc(gtypz_S,Cfld_nbr    ,"MPI_CHARACTER",0,"grid",xnerr)
      call RPN_COMM_bcastc(Cfld_list_S,Cfld_nbr*4,"MPI_CHARACTER",0,"grid",xnerr)
!
!
!*       -------------------------------------------------
!*    6. Interpolate what was just read to the local grid
!*       -------------------------------------------------
!
!*    Start by defining the local grid
!
      offi = Ptopo_gindx(1,Ptopo_myproc+1)-1
      offj = Ptopo_gindx(3,Ptopo_myproc+1)-1
      Do i=1,l_ni
         indx = offi + i
         lxfi(i) = G_xg_8(indx)*rad_8
      End Do
      Do i=1,l_nj
         indx = offj + i
         lyfi(i) = G_yg_8(indx)*rad_8
      End Do
!
      dgid  = ezgdef_fmem( l_ni , l_nj , 'Z', 'E',
     %         Hgc_ig1ro, Hgc_ig2ro, Hgc_ig3ro, Hgc_ig4ro,
     %         lxfi , lyfi )
!
      INTERPOLATE_TO_LOCAL_GRID : Do x=1,Cfld_nbr

!        Only interpolate if new date got read
         If ( Done_Inincr(x) == Do_Inincr(x) 
     %        .and. Lctl_step .ne. 1 ) cycle
!
!        Only interpolate increment if needed
         if ( Cfld_list_S(x) == 'SD' .and. IntIce_L .and. IntSol_L ) cycle
         if ( Cfld_list_S(x) == 'HS' .and. IntSol_L ) cycle
         if ( Cfld_list_S(x) == 'I8' .and. IntIce_L ) cycle

         If ( gtyp_S(x) == 'Z' ) then
            sgid = ezgdef_fmem( xnilu(x), xnjlu(x), gtyp_S(x), 
     %              gtypz_S(x), xnzig1(x),xnzig2(x),xnzig3(x),xnzig4(x),
     %              xrtic(1,x), xrtac(1,x) )
         Else
            sgid = ezgdef_fmem( xnilu(x), xnjlu(x), gtyp_S(x),
     %              Vide_S,     xnig1(x),xnig2(x),xnig3(x),xnig4(x),
     %              Aucun,Aucun )
         End If
!
         xnerr = ezdefset( dgid, sgid )
         xnerr = ezsetopt('INTERP_DEGREE', Cfld_interp_S(x) )
!
         xnerr = ezsint( xrwork(1,1,x), xrclim(1,x) )
!            
!*       And also calculate scaling factors scal_8
         date1 =      Done_Inincr(x) / factor6
         time1 = mod( Done_Inincr(x) , factor6 )*100
         date2 =      Do_Inincr(x)   / factor6
         time2 = mod( Do_Inincr(x)   , factor6 )*100
         xnerr = newdate( stamp1, date1, time1, 3 )
         xnerr = newdate( stamp2, date2, time2, 3 )
         call difdatr( stamp2,stamp1,hour_8 )
         scal_8(x) = 1./(hour_8*(3600./Cstv_dt_8))
!
      End Do INTERPOLATE_TO_LOCAL_GRID
!
!*       -------------------------------------------------
!*    7. We can now update the increments
!*       -------------------------------------------------
!
!*    Loop on the p_nj physics slabs.
!*    The increments are updated in place
      LOOP_ON_THE_P_NJ_PHYSICS_SLABS : do xncoupe=1,p_nj
!
         lowb = (xncoupe-1)*p_bper_siz+1
         upb  =  xncoupe   *p_bper_siz
         busper => Phy_busper3D( lowb : upb )
!
         j = xncoupe+p_offj
!
!        Loop over all variables
         LOOP_OVER_ALL_VARIABLES_3 : do x=1,Cfld_nbr
!
!           Only update increment if new date got read
            if ( Done_Inincr(x) == Do_Inincr(x) 
     %           .and. Lctl_step .ne. 1 ) cycle
!
!           Only update increment if needed
            if ( Cfld_list_S(x) == 'SD' .and. IntIce_L .and. IntSol_L ) cycle
            if ( Cfld_list_S(x) == 'HS' .and. IntSol_L ) cycle
            if ( Cfld_list_S(x) == 'I8' .and. IntIce_L ) cycle
!
            ik = 0
!
!*          Treat each variable different
            select case ( Cfld_list_S(x) )
!
!*          Snow depth. It is used over glaciers and sea-ice when
!*          ICEMELT is false. Soil uses it only with the Force-restore
!*          scheme. Either the maximum GLACIER and GLSEA snow depth (which
!*          are currently in the second and fourth rows) or the soil snow
!*          depth is used here.
            case ( 'SD' )
!
               if (.not.IntIce_L) then
                  do i=1,p_ni
                     neige             = max( busper(snodp+  p_ni+ik) ,
     %                                        busper(snodp+3*p_ni+ik) )
                     busper(incrne+ik) =
     %              (xrwork(p_offi+i,j,x) - neige) * scal_8(x)
                     xrwork(p_offi+i,j,x) = busper(incrne+ik)
                     ik = ik+1
                  enddo
               else
                  do i=1,p_ni
                     busper(incrne+ik) =
     %              (xrwork(p_offi+i,j,x) - busper(snodp +ik)) * scal_8(x)
                     xrwork(p_offi+i,j,x) = busper(incrne+ik)
                     ik = ik+1
                  enddo
               endif
!
!
!*          Soil moisture (again, only for Force-restore) ...
            case ( 'HS' )
!
               do i=1,p_ni
                  busper(incrhs+ik) =
     %           (xrwork(p_offi+i,j,x) - busper(wsoil +ik)) * scal_8(x)
                  xrwork(p_offi+i,j,x) = busper(incrhs+ik)
                  ik = ik+1
               enddo
!
!
!*          Sea ice thickness (if ICEMELT is false) ...
            case ( 'I8' )
!
               do i=1,p_ni
                  busper(incricd+ik) =
     %           (xrwork(p_offi+i,j,x) - busper(icedp +ik)) * scal_8(x)
                  xrwork(p_offi+i,j,x) = busper(incricd+ik)
                  ik = ik+1
               enddo
!
!
!*          Sea ice mask
            case ( 'LG' )
!
               do i=1,p_ni
                  busper(incrgl+ik) =
     %           (xrwork(p_offi+i,j,x) - busper(glsea0+ik)) * scal_8(x)
                  xrwork(p_offi+i,j,x) = busper(incrgl+ik)
                  ik = ik+1
               enddo
!
!
!*          Define the two temperature increments
!*          Busp_incrts is used for SSTs, Busp_incrtg is used in the
!*          second layer Continental Ice temperature and Busp_incrtp
!*          is used with the Force-Restore.
!
!
!*          TP will be used by Force-restore 
!*          and by the glacier module.
            case ( 'TP' )
!
               do i=1,p_ni
                  ! Convert the new temperature from Celsius to Kelvin
                  xrwork(p_offi+i,j,x) = xrwork(p_offi+i,j,x) + Dcst_tcdk_8
!
                  busper(incrtg+ik) = (min( Dcst_trpl_8, 1.0_8*
     %            xrwork(p_offi+i,j,x)) - busper(tglacier+p_ni+ik)) * scal_8(x)
                  busper(incrtp+ik) =
     %           (xrwork(p_offi+i,j,x)  - busper(tsoil   +p_ni+ik)) * scal_8(x)
                  xrwork(p_offi+i,j,x)  = busper(incrtp       +ik)
                  ik = ik+1
!
               enddo
!
!
!*          The sea surface temperature TM
            case ( 'TM' )
!
               do i=1,p_ni
               ! Convert the new temperature from Celsius to Kelvin
                  xrwork(p_offi+i,j,x) = xrwork(p_offi+i,j,x) + Dcst_tcdk_8
!
                  busper(incrts+ik) =
     %           (xrwork(p_offi+i,j,x) - busper(twater+ik)) * scal_8(x)
                  xrwork(p_offi+i,j,x) = busper(incrts+ik)
                  ik = ik+1

               enddo
!
            end select
!
!
!
         end do LOOP_OVER_ALL_VARIABLES_3
!
      end do LOOP_ON_THE_P_NJ_PHYSICS_SLABS
!
!
!*       -------------------------------------------------
!*    8. Optional diagnostics of the increments
!*       -------------------------------------------------
!
      INCREMENT_DIAGNOSTICS : If (Lctl_debug_L .or. VRAI) then
!
         if (G_lam) then
            gii = Glb_pil_e - 2 ; gif = G_ni - Glb_pil_w + 3 
            gji = Glb_pil_s - 2 ; gjf = G_nj - Glb_pil_n + 3 
         else
            gii = 1 ; gif = G_ni
            gji = 1 ; gjf = G_nj
         endif
!
         Do x=1,Cfld_nbr

!           Only do diagnostics if new date got read
            If ( Done_Inincr(x) == Do_Inincr(x) 
     %           .and. Lctl_step /= 1 ) cycle
!
!           Only update increment if needed
            if ( Cfld_list_S(x) == 'SD' .and. IntIce_L .and. IntSol_L ) cycle
            if ( Cfld_list_S(x) == 'HS' .and. IntSol_L ) cycle
            if ( Cfld_list_S(x) == 'I8' .and. IntIce_L ) cycle
!
            call statf_dm( xrwork(1,1,x),Cfld_list_S(x),k+1,
     %       'INCREMENTS',VRAI, 1,l_ni,1,l_nj,1, gii,gji,1, gif,gjf, 1 )
!
         End Do
!
      End If INCREMENT_DIAGNOSTICS
!
!*    De-allocate working memory
      deallocate (xrclim, xrwork, xrtic, xrtac)
!
!
!*    Set flag that new date got read
      do x=1,Cfld_nbr
         Done_Inincr(x) = Do_Inincr(x)
!*       Code date from 'Done_Inincr' in 'Cfld_date' to write in restart file
         date1 =      Done_Inincr(x)/factor6
         time1 = mod( Done_Inincr(x),factor6  ) * 100
         xnerr = newdate( Cfld_date(x), date1, time1, 3 )
      end do
!
!*    De-allocate variable containing all dates in imanclim
!*    at the end of a job
      if ( Lctl_step == Step_total ) deallocate( dates )
!
!
 1001 format(' Unable to open climatological file ',A)
 1002 format(' Analysed/climatological file not opened')
 1004 format(' Climatological ',A4,' will not be read')
 1005 format(' Unable to read climatological ',A4)
 1006 format(' Unable to read >> record on unit ',I3,' for IP1,IP2= ',2I10)
 1007 format(' Unable to read ^^ record on unit ',I3,' for IP1,IP2= ',2I10)
 1009 format(' Date ',I12,' not found in analysed file')
!
      return
      end
