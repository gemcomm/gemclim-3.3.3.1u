!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
*** S/P WATER
*
#include "phy_macros_f.h"
      SUBROUTINE WATER ( bus, bussiz,
     $                   ptsurf, ptsurfsiz,
     $                   trnch, kount,
     $                   n, m, nk )
*
#include "impnone.cdk"
*
      integer bussiz, kount, trnch
      real bus(bussiz)
      integer ptsurfsiz
      integer ptsurf(ptsurfsiz)
*
*
      INTEGER N, M, NK

*
*Author
*          J. Mailhot, S. Belair and B. Bilodeau (Dec 1998)
*
*Revisions
* 001      B. Bilodeau (Nov 2000) - New comdeck sfcbus.cdk
* 002      B. Bilodeau (Jan 2001) - Automatic arrays
* 003      B. Bilodeau (Aug 2001) - LOCBUS
* 004      B. Bilodeau (Feb 2002) - Add Z0TCST option
* 005      J.-F. Mahfouf (Spring 2003) - 
*              Add implicit boundary condition option for vert. diff.
* 006      A.-M. Leduc and B. Bilodeau (April 2004) - Add Z0tlat 
*              (latitudinal variation of z0t between Charnock 
*               and a constant value)
* 008      M. Faucher (Summer 2006) - If OWFLUX. is .true. in coupling mode,
*                fluxes over ocean are taken from ocean model.
* 009      B. Dugas (Jan 2009) - VAMIN is now included in OPTIONS
* 010      M. Carrera and V. Fortin (Nov 2007) - Compute total runoff
*                as precipitation - evaporation (no storage)
* 011      A.-M. Leduc and P.vaillancourt (Jan 2010) - Moon and Deacu formulations
*              for Z0M and Deacu formulation for Z0H. Also, reduced staturation
*              specific humidity due to sea salt over oceans. All of these
*              are controlled via logical OPTIONS WATER_(QS/Z0M/Z0H).
* 012      B. Dugas (Jul 2011) - Remove last traces of fccpl, fvcpl and mccpl
*
*Object
*          Calculate: - surface roughness length (Z0) over open water
*                       (not covered by ice) using Charnock's relation with a 
*                       BETA parameter (optional sea state dependency);
*                     - surface fluxes of momentum, heat and moisture.
*
*Arguments
*
*             - Input/Output -
* BUS         Bus for the WATER surface scheme
*
*             - Input -
* BUSSIZ      dimension of bus
* PTSURF      surface pointers
* PTSURFSIZ   dimension of ptsurf
* TRNCH       row number
* KOUNT       timestep number
* N           horizontal dimension (row length)
* M           horizontal dimensions of fields
*             (not used for the moment)
* NK          vertical dimension
*
*
*Notes
*          Z0 = BETA*USTAR**2/GRAV (in metres) with minimum value
*          Z0MIN and a maximum value Z0MAX
*
*IMPLICITES
*
#include "consphy.cdk"
*
#include "clefcon.cdk"
#include "options.cdk"
*
      integer ptr, x
      INTEGER I, J, K
*
*
*
*MODULES
*
      EXTERNAL FLXSURF3
*
*
****************************************************
*     AUTOMATIC ARRAYS
****************************************************
*
      AUTOMATIC ( VMOD  , REAL , (N) )
      AUTOMATIC ( SCR1  , REAL , (N) )
      AUTOMATIC ( SCR2  , REAL , (N) )
      AUTOMATIC ( SCR3  , REAL , (N) )
      AUTOMATIC ( SCR4  , REAL , (N) )
      AUTOMATIC ( SCR5  , REAL , (N) )
      AUTOMATIC ( SCR6  , REAL , (N) )
      AUTOMATIC ( SCR7  , REAL , (N) )
      AUTOMATIC ( ZTN   , REAL , (N) )
      AUTOMATIC ( ZUN   , REAL , (N) )
*
****************************************************
*
      REAL BETA, RHO
*
      REAL ALVIS_WAT, CMU, CTU, FC_WAT
      REAL MLAC
      REAL FV_WAT
      REAL HST_WAT, HU, ILMO_WAT
      REAL PS, QS, TH, TS, TT, UU, VV
      REAL Z0H, Z0M, Z0L(N)
      REAL ZALFAQ, ZALFAT, ZDLAT, ZFCOR
      REAL ZFTEMP, ZFVAP, ZQDIAG, ZRUNOFFTOT
      REAL ZRAINRATE, ZSNOWRATE
      REAL ZTDIAG, ZTSURF, ZTSRAD, ZUDIAG, ZVDIAG 
      REAL ZFRV, ZZUSL, ZZTSL
      REAL windcrit

      REAL ZFRVMIN
*
      POINTER (IALVIS_WAT , ALVIS_WAT  (1) )
      POINTER (ICMU       , CMU        (1) )
      POINTER (ICTU       , CTU        (1) )
      POINTER (IML        , MLAC       (1) )
      POINTER (IFC   _WAT , FC   _WAT  (1) )
      POINTER (IFV   _WAT , FV   _WAT  (1) )
      POINTER (IHST  _WAT , HST  _WAT  (1) )
      POINTER (IHU        , HU         (1) )
      POINTER (IILMO _WAT , ILMO _WAT  (1) )
      POINTER (IPS        , PS         (1) )
      POINTER (IQS        , QS         (1) )
      POINTER (ITH        , TH         (1) )
      POINTER (ITS        , TS         (1) )
      POINTER (ITT        , TT         (1) )
      POINTER (IUU        , UU         (1) )
      POINTER (IVV        , VV         (1) )
      POINTER (IZ0H       , Z0H        (1) )
      POINTER (IZ0M       , Z0M        (1) )
      POINTER (IZALFAQ    , ZALFAQ     (1) )
      POINTER (IZALFAT    , ZALFAT     (1) )
      POINTER (IZDLAT     , ZDLAT      (1) )
      POINTER (IZFCOR     , ZFCOR      (1) )
      POINTER (IZFTEMP    , ZFTEMP     (1) )
      POINTER (IZFVAP     , ZFVAP      (1) )
      POINTER (IZQDIAG    , ZQDIAG     (1) )
      POINTER (IZRFTOT    , ZRUNOFFTOT (1) )
      POINTER (IZRAINRATE , ZRAINRATE  (1) )
      POINTER (IZSNOWRATE , ZSNOWRATE  (1) )
      POINTER (IZTDIAG    , ZTDIAG     (1) )
      POINTER (IZTSURF    , ZTSURF     (1) )
      POINTER (IZTSRAD    , ZTSRAD     (1) )
      POINTER (IZUDIAG    , ZUDIAG     (1) )
      POINTER (IZVDIAG    , ZVDIAG     (1) )
      POINTER (IZFRV      , ZFRV       (1) )
      POINTER (IZZUSL     , ZZUSL      (1) )
      POINTER (IZZTSL     , ZZTSL      (1) )
*
*
***
*
#include "zuzt.cdk"
*
      REAL Z0MAX, Z0HCON
      SAVE Z0MAX, Z0HCON
*
***
*
***  WARNING ------ the value for Z0MAX needs to be increased when coupled with WAM
*
***   DATA Z0MAX / 5.E-2 /
      DATA Z0MAX / 5.E-3 /
      DATA Z0HCON/ 4.E-5/
*
*** ------------------------------------------------------------------
*
#include "locbus.cdk"
      INTEGER INDX_SFC, SURFLEN
      PARAMETER (INDX_SFC = INDX_WATER)
      INTEGER QUELNIVO(MAXVARSURF)
*
*
#include "sfcbus.cdk"
*
#include "dintern.cdk"
#include "fintern.cdk"
#include "xptsurf.cdk"
*
*
*
      SURFLEN = M
*
*
*     EQUIVALENCES
*
      INIT_LOCBUS()
*
*     Syntax of macro locbus (must be typed in CAPITAL letters):
*     locbus (pointer, array_name_in_the_bus, level)
*     If level=0, array chosen automatically as follows:
*        1) level =  1 if array has  1 level only (e.g. TSURF )
*        2) level = nk if array has nk levels     (e.g. TMOINS)
*        3) level = indx_sfc if array has a level for each surface type (e.g. FC)
*        4) level has to be specified by user if array has more than one level
*           that all "belong" to the same surface type (e.g. TSOIL)
*
      LOCBUS (IALVIS_WAT, ALVIS  ,  0 )
      LOCBUS (ICMU      , BM     ,  0 )
      LOCBUS (ICTU      , BT     ,  0 )
      LOCBUS (IML       , ML     ,  0 )
      LOCBUS (IFC_WAT   , FC     ,  0 )
      LOCBUS (IFV_WAT   , FV     ,  0 )
      LOCBUS (IHST_WAT  , HST    ,  0 )
      LOCBUS (IHU       , HUMOINS,  0 )
      LOCBUS (IILMO_WAT , ILMO   ,  0 )
      LOCBUS (IPS       , PMOINS ,  0 )
      LOCBUS (IQS       , QSURF  ,  0 )
      LOCBUS (ITH       , THETAA ,  0 )
      LOCBUS (ITS       , TWATER ,  0 )
      LOCBUS (ITT       , TMOINS ,  0 )
      LOCBUS (IUU       , UMOINS ,  0 )
      LOCBUS (IVV       , VMOINS ,  0 )
      LOCBUS (IZ0H      , Z0T    ,  0 )
      LOCBUS (IZ0M      , Z0     ,  0 )
      LOCBUS (IZALFAQ   , ALFAQ  ,  0 )
      LOCBUS (IZALFAT   , ALFAT  ,  0 )
      LOCBUS (IZDLAT    , DLAT   ,  0 )
      LOCBUS (IZFCOR    , FCOR   ,  0 )
      LOCBUS (IZFTEMP   , FTEMP  ,  0 )
      LOCBUS (IZFVAP    , FVAP   ,  0 )
      LOCBUS (IZTSURF   , TSURF  ,  0 )
      LOCBUS (IZTSRAD   , TSRAD  ,  0 )
      LOCBUS (IZUDIAG   , UDIAG  ,  0 )
      LOCBUS (IZVDIAG   , VDIAG  ,  0 )
      LOCBUS (IZTDIAG   , TDIAG  ,  0 )
      LOCBUS (IZQDIAG   , QDIAG  ,  0 )
      LOCBUS (IZRFTOT   , RUNOFFTOT ,  0 )
      LOCBUS (IZRAINRATE, RAINRATE, 0 )
      LOCBUS (IZSNOWRATE, SNOWRATE, 0 )
      LOCBUS (IZFRV     , FRV    ,  0 )
      LOCBUS (IZZUSL    , ZUSL   ,  0 )
      LOCBUS (IZZTSL    , ZTSL   ,  0 )
*
      do i=1,n
         zun(i) = zu
         ztn(i) = zt
      end do
*
*------------------------------------------------------------------------
*
*
*       1.     Saturated specific humidity at the water surface
*       -------------------------------------------------------
*
*                           Uses FOQSA instead of FOQST to take into account saturation
*                           with respect to sea water (liquid between 0 and -1.8 C)
      DO I=1,N
        QS(I) = FOQSA(TS(I),PS(I))
        IF(WATER_QS .and. MLAC(I) <= 0.001) QS(I) = 0.98*QS(I)
      END DO
*
*
*
*       2.     Calculate roughness lengths based on generalized Charnock's relation 
*       ---------------------------------------------------------------------------
*
      beta = 0.018
      windcrit= 12.5
      ZFRVMIN=0.01

      DO I=1,N
        VMOD  (I) = SQRT(MAX(VAMIN,UU(I)**2+VV(I)**2))
      END DO


*     min of zfrv to have no impact on z0m is given by sqrt(g*z0min/beta)
*     will also solve the division by zero peroblem for z0h

      if (WATER_Z0M) then

*        New formulation of Z0M from Daniel Deacu and for winds 
*        stronger than 12.5 m/s new formulation of Z0M from Moon.

         DO I=1,N
            ZFRV(I)=MAX(ZFRVMIN,  ZFRV(I))
  
            if (VMOD(I) .le. windcrit) then
               Z0M(I) =MIN( BETA*ZFRV(I)**2/GRAV + 1.65e-06/ ZFRV(I) ,Z0MAX )
            else
               Z0M(I)= MAX ( (0.085*(-0.56*ZFRV(I)**2+20.255*ZFRV(I)+2.458)-0.58)/1000. , Z0MIN )
            endif

         END DO

      else
       
         if (kount.gt.0) then
            DO I=1,N
               Z0M(I) = MAX( MIN( BETA*ZFRV(I)**2/GRAV,Z0MAX ) , Z0MIN )
            END DO
         endif

         Z0L(1:N) = Z0M(1:N)

      endif

*
*
*     Note:  For |lat| >= Z0TLAT(2)  Charnock's relation is used 
*            For |lat| <= Z0TLAT(1)  Z0HCON is used.
*            For Z0TLAT(1) < |lat| < Z0TLAT(2)
*            we do a linear interpolation between Charnock and Z0HCON.
*
      if (WATER_Z0H) then
*        New formulation of Z0H from Daniel Deacu
         DO I=1,N
            Z0L(I) = MIN(2.e-05/ZFRV(I), 1.e-04)
         END DO 
      endif

      DO I=1,N

        IF (ABS(ZDLAT(I)) .GE. Z0TLAT(2)) THEN 
          Z0H(I) = Z0L(I)
        ELSE IF (ABS(ZDLAT(I)) .LE. Z0TLAT(1)) THEN
          Z0H(I) = Z0HCON
        ELSE
          Z0H(I)=( ((ABS(ZDLAT(I))-Z0TLAT(1))/(Z0TLAT(2)-Z0TLAT(1)))
     +                  *(Z0L(I)-Z0HCON) ) + Z0HCON
        ENDIF
   
      END DO


*
*
*       3.     Calculate the surface transfer coefficient and fluxes 
*       ------------------------------------------------------------
*
      CALL FLXSURF3( CMU, CTU, SCR1, ZFTEMP, ZFVAP,
     $               ILMO_WAT, ZFRV, ZFCOR, TH, HU,
     $               ZZUSL, ZZTSL, VMOD, TS, QS, HST_WAT,
     $               Z0M, Z0H,SCR2, SCR3, SCR4, SCR5, N ) 
*
*
      CALL DIASURF2(ZUDIAG, ZVDIAG, ZTDIAG, ZQDIAG,
     $              N, UU, VV, TS, QS,
     $              Z0M, Z0H, ILMO_WAT, ZZUSL,
     $              HST_WAT, ZFRV, ZFTEMP, ZFVAP,
     $              ZUN, ZTN, ZDLAT)
*
*
*
*       4.     Finalize the fluxes
*       --------------------------
*
*VDIR NODEP
      DO I=1,N
*
        ZTSURF   (I) = TS (I)
        ZTSRAD   (I) = TS (I)
*
        ZALFAT   (I) = - CTU(I) * ( TS(I)-TH(I) )
        ZALFAQ   (I) = - CTU(I) * ( QS(I)-HU(I) )
        IF (.NOT.IMPFLX) CTU (I) = 0.
        RHO = PS(I)/(RGASD * ZTDIAG(I)*(1.+DELTA*ZQDIAG(I)))
* Compute runoff as total precipitation in kg/m2/s (or mm/s) minus evaporation.
* ZALFAQ being negative for an upward flux, we need to add rho*zalfaq        
        ZRUNOFFTOT (I) = (1000.*(ZRAINRATE(I) + ZSNOWRATE(I))
     1                   + RHO*ZALFAQ(I))
        FC   _WAT(I) = -CPD *RHO*ZALFAT(I)
        FV   _WAT(I) = -CHLC*RHO*ZALFAQ(I)
*
        IF (IMPFLX) THEN
          ZALFAT   (I) = - CTU(I) *  TS(I)
          ZALFAQ   (I) = - CTU(I) *  QS(I) 
        ENDIF
****
*
      END DO
*
*     FILL THE ARRAYS TO BE AGGREGATED LATER IN S/R AGREGE
      CALL FILLAGG ( BUS, BUSSIZ, PTSURF, PTSURFSIZ, INDX_WATER,
     +               SURFLEN )
*
      RETURN
      CONTAINS
#include "fintern90.cdk"
      END
